#!/bin/sh

# my_snapshots/                 your folder to store the snapshots in
# |- rsync_snapshot.sh          this script
# |- exclude.list               list of files to be excluded
# |- include.list               list of files to be included
# `- snapshots/                 folder generated by script to store snapshots
#    |- YYMMDD-hhmmss/          snapshot folder
#    |  |- system/              snapshot of the root system
#    |  |- exclude.list         excluded files for this snapshot
#    |  |- rsync.log            rsync log for this snapshot
#    |  `- script.sh            script used for this snapshot
#    `- last -> YYMMDD-hhmmss/  links to last snapshot


function prompt_yn() {
  read -e -p "$1 [Y/n]: " yn
  if [[ "$yn" == "" ]] || [[ "$yn" == [Yy]* ]]; then
  	return 0
  fi
  return 1
}

function snapshotList() { # SAVE_PATH
	SAVE_PATH=$1
	totalSizeBytes=0
	# header
	echo "   # │ Date                     │      Size │    Actual"
	echo "─────┼──────────────────────────┼───────────┼──────────"
	i=0
	for SNAP_LOG in $(ls "$SAVE_PATH"/snapshots/??????-??????/rsync.log); do
		D=$(basename $(dirname "$SNAP_LOG")) # DATE
		# YYMMDD-hhmmss -> YYMMDD-hh:mm:ss
		PARSED="20${D:0:6} ${D:7:2}:${D:9:2}:${D:11:2}"
		FORMATTED=$(date -d"$PARSED" +"%a %d %b %Y %T")

		LOG_TAIL=$(tail -n 2 "$SNAP_LOG")
		SIZE=$(echo "$LOG_TAIL" | xargs | awk '{ print $18 }')
		ACTUAL_SIZE=$(echo "$LOG_TAIL" | xargs | awk '{ print $5 }')

		# <SNAPSHOT NUMBER> |
		printf "%4s │" "$i"
		# <DATE> |
		printf " $FORMATTED │"
		# <SIZE> |
		numfmt --zero-terminated --from=si --to=iec-i --round=nearest --suffix="B" --format="%10.1f │" "$SIZE"
		# <ACTUAL SIZE> |
		numfmt --zero-terminated --from=si --to=iec-i --round=nearest --suffix="B" --format="%10.1f" "$ACTUAL_SIZE"
		# newline
		echo
		((i++))

		# count total snapshots size
		snapshotSizeBytes=$(numfmt --from=si "$ACTUAL_SIZE")
		totalSizeBytes=$(($totalSizeBytes + $snapshotSizeBytes))
	done

	totalSizeHuman=$(numfmt --to=iec-i --round=nearest --suffix="B" --format=%.2f "$totalSizeBytes")
	printf "%55s\n" "Total disk space used: $totalSizeHuman"
}

function snapshotCreate() { # SAVE_PATH
	SAVE_PATH=$1

	# snapshot_s_ path
	SNAPSHOTS_FOLDER=$SAVE_PATH/snapshots
	if [[ ! -d $SNAPSHOTS_FOLDER ]]; then
		echo "Creating $SNAPSHOTS_FOLDER folder"
		mkdir "$SNAPSHOTS_FOLDER"
	fi

	# exclude file
	MASTER_EXCLUDE_FILE="$SAVE_PATH/exclude.list"
	MASTER_INCLUDE_FILE="$SAVE_PATH/include.list"
	## exclude.list or include.list not found, probably first time running script
	if [[ ! -f "$MASTER_EXCLUDE_FILE" ]] || [[ ! -f "$MASTER_INCLUDE_FILE" ]]; then
		if [[ ! -f "$MASTER_EXCLUDE_FILE" ]]; then
			# create template exclude file
			echo "/dev/*" >$MASTER_EXCLUDE_FILE
			echo "/proc/*" >>$MASTER_EXCLUDE_FILE
			echo "/sys/*" >>$MASTER_EXCLUDE_FILE
			echo "/run/*" >>$MASTER_EXCLUDE_FILE
			echo "/tmp/*" >>$MASTER_EXCLUDE_FILE
			echo "/mnt/*" >>$MASTER_EXCLUDE_FILE
			echo "/lost+found" >>$MASTER_EXCLUDE_FILE
			echo "" >>$MASTER_EXCLUDE_FILE
			echo "/var/run/*" >>$MASTER_EXCLUDE_FILE
			echo "/var/lock/*" >>$MASTER_EXCLUDE_FILE
			echo "/var/tmp/*" >>$MASTER_EXCLUDE_FILE
			echo "" >>$MASTER_EXCLUDE_FILE
			echo "/home/*/.cache/*" >>$MASTER_EXCLUDE_FILE

			echo "Created '$MASTER_EXCLUDE_FILE' with a default exclude template,"
		fi
		if [[ ! -f "$MASTER_INCLUDE_FILE" ]]; then
			echo "/" >$MASTER_INCLUDE_FILE
			echo "Created '$MASTER_INCLUDE_FILE' with a default include template,"
		fi
		echo "Please review/modify them and run script again"
		exit
	fi

	# snapshot path
	SNAPSHOT_PATH=$SNAPSHOTS_FOLDER/$(date +'%y%m%d-%H%M%S')
	mkdir "$SNAPSHOT_PATH"

	# last snapshot
	SNAPSHOT_LAST=$SNAPSHOTS_FOLDER/last

	# snapshot backup location
	SNAPSHOT_LOCATION=$SNAPSHOT_PATH/system
	mkdir "$SNAPSHOT_LOCATION"

	# snapshot log
	SNAPSHOT_LOG=$SNAPSHOT_PATH/rsync.log

	# copy exclude and include files to snapshot folder as it may change over time
	EXCLUDE_FILE=$SNAPSHOT_PATH/exclude.list
	cp "$MASTER_EXCLUDE_FILE" "$EXCLUDE_FILE"
	INCLUDE_FILE=$SNAPSHOT_PATH/include.list
	cp "$MASTER_INCLUDE_FILE" "$INCLUDE_FILE"

	# copy this script to snapshot folder as it may also change in future
	SCRIPT_FILE=$SNAPSHOT_PATH/script.sh
	cp "$0" "$SCRIPT_FILE"

	## delete partial snapshots on ctrl-c
	function interruptHandler() {
		echo "Operation canceled, deleting partial snapshot..."
		rm -rf "$SNAPSHOT_PATH"
		echo "Partial snapshot deleted, exiting."
		exit
	}
	trap interruptHandler SIGINT

	# rsync will autoescape any bash variables passed as params so passing a space
	# seperated string of srcs wont work as it will be read as a single filename
	# a workaround is to store the src directories in an array and use the [*]
	# array operator to pass the files to rsync
	IFS='' # split on newlines not whitespaces
	readarray -t SRC_FILES <$INCLUDE_FILE

	## rsync paramaters
	# if first snapshot dosent exist dont include --link-dest
	if [[ -d $SNAPSHOT_LAST ]]; then
		LINK_DEST="--link-dest=$(realpath $SNAPSHOT_LAST)/system/"
	fi

	echo "Started creating snapshot"

	## rsync command
	rsync \
		-aHAX -vh \
		$LINK_DEST \
		--exclude-from=$EXCLUDE_FILE \
		--log-file=$SNAPSHOT_LOG \
		--relative \
		${SRC_FILES[*]} \
		$SNAPSHOT_LOCATION

	echo "Successfully created snapshot."

	# update latest snapshot pointer
	rm -f $SNAPSHOT_LAST
	ln -s $(basename $SNAPSHOT_PATH) $SNAPSHOT_LAST

	echo "syncing drive..."
	sync $SNAPSHOT_LOCATION
}

function snapshotHelp() {
	cat <<EOF
usage: $0 <command> [snapshot location] [--no-root]

  Create snapshot:
    $0 create [snapshot location] [--no-root]
        Creates snapshot, pass snapshot location as paramater or leave empty to
        default to current directory
        by default will require the user to be root, to bypass this pass the
        --no-root paramter at the end of the comand

  List snapshots:
    $0 list [snapshot location]
        List past snapshot details, includes size, date and total snapshot size
        footprint
	
  Delete snapshot:
    $0 delete [snapshot location] [snapshot number] [--no-root]
        Delete snapshot by number, find snapshot number with the list command
        Negative numbers are also accepted

  Help:
    $0 help
        Display this menu

EOF
}

function snapshotDelete() { # SAVE_PATH, SNAPSHOT_NUM
	SAVE_PATH=$1
	SNAPSHOT_NUM=$2

	# calculate snapshot number if number is negative
	SNAP_COUNT=$(ls -1d "$SAVE_PATH"/snapshots/??????-?????? | wc -l)
	if [ $SNAPSHOT_NUM -lt 0 ]; then
		SNAPSHOT_NUM=$(($SNAP_COUNT + $SNAPSHOT_NUM - 1))
	fi

	# find snapshot number is pointing to
	i=0
	for SNAP in $(ls -1d "$SAVE_PATH"/snapshots/??????-??????); do
		if [ $i -eq $SNAPSHOT_NUM ]; then
			DELETE_SNAPSHOT=$SNAP
			break
		fi
		((i++))
	done

	# number does not refrence any snapshot
	if [ -z $DELETE_SNAPSHOT ]; then
		echo "Snapshot not found, use the list command show snapshots"
		exit 1
	fi

	# user confirmation
	read -e -p "Are you sure you want to delete snapshot $DELETE_SNAPSHOT [y/N]: " yn
  [[ "$yn" == [Yy]* ]] || exit 1

	echo "Deleting snapshot..."
	if rm -rf "$DELETE_SNAPSHOT"; then
		echo "Snapshot deleted"
	else
		echo "Failed to delete snapshot"
		exit 1
	fi

	# update latest snapshot pointer
	if [ $SNAP_COUNT -gt 1 ]; then # check that all snapshots arent deleted
		LAST_SNAPSHOT=$(ls -1d "$SAVE_PATH"/snapshots/??????-?????? | tail -n1)
		unlink "$SAVE_PATH"/snapshots/last
		ln -sf "$(basename "$LAST_SNAPSHOT")" "$SAVE_PATH"/snapshots/last
	fi
}

# set command to first argument passed
COMMAND=$1
[[ $# -gt 0 ]] && shift

# parse command arguments
FORCE_ROOT=true # default to true
NUM_ARG=-1      # default to -1
PATH_ARG="."    # default to '.'
while [[ $# -gt 0 ]]; do
	case $1 in
	--no-root)
		FORCE_ROOT=false
		shift
		;;
	*)
		if [[ "$1" =~ ^\-?[0-9]+$ ]]; then
			NUM_ARG=$1
		else
			PATH_ARG=$1
		fi
		shift
		;;
	esac
done

function checkIfRoot() {
	## ignore check if --no-root argument passed
	[ "$FORCE_ROOT" == false ] && return

	## check if root
	if [ "$FORCE_ROOT" = true ] && [ $UID -ne 0 ]; then
		echo "run as root or use the --no-root argument"
		exit 1
	fi
}

case $COMMAND in
"create" | "c")
	checkIfRoot
	snapshotCreate "$PATH_ARG"
	;;
"list" | "l")
	snapshotList "$PATH_ARG"
	;;
"delete" | "d")
	checkIfRoot
	snapshotDelete "$PATH_ARG" "$NUM_ARG"
	;;
"help" | "h" | "")
	snapshotHelp
	;;
*)
	echo "Unknown command \"$COMMAND\""
	snapshotHelp
	;;
esac
